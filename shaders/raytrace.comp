#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

layout(set = 0, binding = 0, rgba8) uniform image2D outputImage;

struct Sphere {
    vec3 center;
    float radius;
    int materialIndex;
    int padding[3];
};

layout(set = 0, binding = 1) readonly buffer SphereBuf {
    Sphere sphereData[];
} sphereBuffer;

struct Material {
    vec4 colorAndAmbient;      // color.xyz, ambient.w
    vec4 diffuseSpecularShiny; // diffuse.x, specular.y, shininess.z, reflectivity.w
    vec4 transIsoEmissive;     // transparency.x, isVolumetric.y, emissiveStrength.z, padding.w
    vec4 emissive;             // emissive.xyz, padding.w
    vec4 scatterAndAbsorption; // scatterColor.xyz, absorptionCoeff.w
};

layout(set = 0, binding = 2, std430) readonly buffer MaterialBuf {
    Material materialData[];
} materialBuffer;

layout(set = 0, binding = 3) readonly buffer LightBuf {
    vec4 lightData[];
} lightBuffer;

layout(set = 0, binding = 4) readonly buffer VolumeBuf {
    vec4 volumeData[];
} volumeBuffer;

layout(set = 0, binding = 5) readonly buffer VoxelDataBuf {
    uint voxelData[];
} voxelDataBuffer;

layout(push_constant) uniform PushConstants {
    mat4 cameraMatrix;
    vec3 cameraPos;
    float time;
    int numSpheres;
    int numLights;
    int numVolumes;
    int maxDepth;
    vec3 bgColorTop;
    float padding1;
    vec3 bgColorBottom;
    float padding2;
} pushConst;

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct HitRecord {
    vec3 point;
    vec3 normal;
    float t;
    int materialIndex;
    bool hit;
};

const float PI = 3.14159265359;
const float MAX_DISTANCE = 1e10;
const float EPSILON = 0.001;

float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

Ray createCameraRay(vec2 uv) {
    Ray ray;
    ray.origin = pushConst.cameraPos;
    
    vec3 target = vec3(2.0, 1.5, 0.0);
    vec3 forward = normalize(target - ray.origin);
    vec3 right = normalize(cross(forward, vec3(0, 1, 0)));
    vec3 up = normalize(cross(right, forward));
    
    float fov = tan(radians(60.0) / 2.0);
    float aspectRatio = imageSize(outputImage).x / float(imageSize(outputImage).y);
    
    ray.direction = normalize(
        forward + 
        (uv.x - 0.5) * aspectRatio * fov * right + 
        (uv.y - 0.5) * fov * up
    );
    
    return ray;
}

// Sphere intersection
bool hitSphere(Ray ray, vec3 center, float radius, float tMin, float tMax, inout HitRecord rec) {
    vec3 oc = ray.origin - center;
    float a = dot(ray.direction, ray.direction);
    float b = 2.0 * dot(oc, ray.direction);
    float c = dot(oc, oc) - radius * radius;
    
    float discriminant = b * b - 4.0 * a * c;
    if (discriminant < 0.0) return false;
    
    float sqrtDisc = sqrt(discriminant);
    float t = (-b - sqrtDisc) / (2.0 * a);
    
    if (t < tMin || t > tMax) {
        t = (-b + sqrtDisc) / (2.0 * a);
        if (t < tMin || t > tMax) return false;
    }
    
    rec.t = t;
    rec.point = ray.origin + t * ray.direction;
    rec.normal = normalize(rec.point - center);
    rec.hit = true;
    
    return true;
}

bool traceRay(Ray ray, out HitRecord rec, float tMin, float tMax) {
    float closestT = tMax;
    bool hitAnything = false;
    
    for (int i = 0; i < pushConst.numSpheres; i++) {
        vec3 center = sphereBuffer.sphereData[i].center;
        float radius = sphereBuffer.sphereData[i].radius;
        
        HitRecord tempRec;
        if (hitSphere(ray, center, radius, tMin, closestT, tempRec)) {
            closestT = tempRec.t;
            rec = tempRec;
            rec.materialIndex = sphereBuffer.sphereData[i].materialIndex;
            hitAnything = true;
        }
    }
    
    return hitAnything;
}

float getShadowFactor(vec3 point, vec3 lightPos) {
    Ray shadowRay;
    shadowRay.origin = point;
    shadowRay.direction = normalize(lightPos - point);
    float distToLight = length(lightPos - point);
    
    HitRecord rec;
    if (traceRay(shadowRay, rec, EPSILON, distToLight)) {
        return 0.0;
    }
    return 1.0;
}

vec3 calculateLighting(HitRecord rec, vec3 viewDir) {
    vec3 finalColor = vec3(0.0);
    
    vec3 surfaceColor = vec3(0.8);
    if (rec.materialIndex >= 0 && rec.materialIndex < pushConst.numSpheres + 16) {
        Material mat = materialBuffer.materialData[rec.materialIndex];
        surfaceColor = mat.colorAndAmbient.xyz;
    }
    
    vec3 ambient = vec3(0.1) * surfaceColor;
    finalColor += ambient;
    
    for (int i = 0; i < pushConst.numLights; i++) {
        vec3 lightPos = lightBuffer.lightData[i].xyz;
        float intensity = lightBuffer.lightData[i].w;
        
        float shadowFactor = getShadowFactor(rec.point, lightPos);
        if (shadowFactor < 0.5) continue;
        
        vec3 lightDir = normalize(lightPos - rec.point);
        float distance = length(lightPos - rec.point);
        
        float attenuation = intensity / (1.0 + 0.09 * distance + 0.032 * distance * distance);
        
        float diffuseStrength = max(0.0, dot(rec.normal, lightDir));
        vec3 diffuse = vec3(0.7) * diffuseStrength * surfaceColor * attenuation;
        
        vec3 halfDir = normalize(lightDir + viewDir);
        float specularStrength = pow(max(0.0, dot(rec.normal, halfDir)), 32.0);
        vec3 specular = vec3(0.3) * specularStrength * vec3(1.0, 1.0, 1.0) * attenuation;
        
        finalColor += (diffuse + specular) * shadowFactor;
    }
    
    return finalColor;
}

float sampleVolume(vec3 worldPos, int volumeIndex) {
    if (volumeIndex >= pushConst.numVolumes) return 0.0;
    
    // Read volume data from buffer (4 vec4s per volume)
    int baseIndex = volumeIndex * 4;
    vec3 volPos = volumeBuffer.volumeData[baseIndex].xyz;
    vec3 v0 = volumeBuffer.volumeData[baseIndex + 1].xyz;
    int res_x = floatBitsToInt(volumeBuffer.volumeData[baseIndex + 1].w);
    vec3 v1 = volumeBuffer.volumeData[baseIndex + 2].xyz;
    int res_y = floatBitsToInt(volumeBuffer.volumeData[baseIndex + 2].w);
    int res_z = floatBitsToInt(volumeBuffer.volumeData[baseIndex + 3].x);
    
    vec3 relPos = worldPos - volPos;
    
    if (any(lessThan(relPos, v0)) || any(greaterThan(relPos, v1))) {
        return 0.0;
    }
    
    relPos = (relPos - v0) / (v1 - v0);
    
    ivec3 voxelIdx = ivec3(relPos * vec3(float(res_x), float(res_y), float(res_z)));
    voxelIdx = clamp(voxelIdx, ivec3(0), ivec3(res_x - 1, res_y - 1, res_z - 1));
    
    int index = voxelIdx.x + voxelIdx.y * res_x + voxelIdx.z * res_x * res_y;
    
    // Extract byte from packed uint array
    int uintIndex = index / 4;
    int byteInUint = index % 4;
    uint packedData = voxelDataBuffer.voxelData[uintIndex];
    uint byteValue = (packedData >> (byteInUint * 8)) & 0xFF;
    
    return float(byteValue) / 255.0;
}

bool intersectBox(Ray ray, vec3 boxMin, vec3 boxMax, out float tNear, out float tFar) {
    vec3 invDir = 1.0 / ray.direction;
    vec3 t0 = (boxMin - ray.origin) * invDir;
    vec3 t1 = (boxMax - ray.origin) * invDir;
    
    vec3 tmin = min(t0, t1);
    vec3 tmax = max(t0, t1);
    
    tNear = max(max(tmin.x, tmin.y), tmin.z);
    tFar = min(min(tmax.x, tmax.y), tmax.z);
    
    return tFar >= tNear && tFar > 0.0;
}

vec3 rayMarchVolume(Ray ray, float maxDist, int volumeIndex) {
    if (pushConst.numVolumes <= 0) return vec3(-1.0);
    
    // Read volume data from buffer (4 vec4s per volume)
    int baseIndex = volumeIndex * 4;
    vec3 volPos = volumeBuffer.volumeData[baseIndex].xyz;
    vec3 v0 = volumeBuffer.volumeData[baseIndex + 1].xyz;
    vec3 v1 = volumeBuffer.volumeData[baseIndex + 2].xyz;
    int materialIndex = floatBitsToInt(volumeBuffer.volumeData[baseIndex + 3].y);
    
    vec3 boxMin = volPos + v0;
    vec3 boxMax = volPos + v1;
    
    float tNear, tFar;
    if (!intersectBox(ray, boxMin, boxMax, tNear, tFar)) {
        return vec3(-1.0);
    }
    
    tNear = max(tNear, 0.0);
    tFar = min(tFar, maxDist);
    
    vec3 materialColor = vec3(0.7, 0.5, 0.3);
    
    // Ray march and count solid voxels
    float stepSize = 0.01;
    float t = tNear;
    int stepCount = 0;
    int nonZeroCount = 0;
    
    while (t < tFar && stepCount < 1000) {
        vec3 samplePos = ray.origin + ray.direction * t;
        float density = sampleVolume(samplePos, volumeIndex);
        
        if (density > 0.0) {
            nonZeroCount++;
        }
        
        t += stepSize;
        stepCount++;
    }
    
    if (nonZeroCount > 0) {
        float ratio = float(nonZeroCount) / float(stepCount);
        return materialColor * ratio;
    }
    
    return vec3(-1.0);
}

vec3 renderVolumetric(Ray ray) {
    if (pushConst.numVolumes <= 0) {
        return vec3(0.0);
    }
    
    return rayMarchVolume(ray, 100.0, 0);
}

vec3 traceIterative(Ray initialRay) {
    vec3 finalColor = vec3(0.0);
    float accumulatedOpacity = 0.0;
    const float OPACITY_THRESHOLD = 0.999;
    
    Ray currentRay = initialRay;
    float tMin = EPSILON;
    
    for (int bounce = 0; bounce < 10; bounce++) {
        if (accumulatedOpacity >= OPACITY_THRESHOLD) break;
        
        HitRecord rec;
        
        // Check for volumetric intersection first
        vec3 volumetricContribution = rayMarchVolume(currentRay, MAX_DISTANCE, 0);
        float volumeT = MAX_DISTANCE;
        float volumeAlpha = 0.0;
        
        if (volumetricContribution.x >= 0.0) {
            vec3 maxColor = vec3(0.7, 0.5, 0.3);
            volumeAlpha = length(volumetricContribution) / length(maxColor);
            volumeAlpha = clamp(volumeAlpha, 0.0, 1.0);
            
            // Approximate volumeT as the center of the volume
            int baseIndex = 0 * 4;
            vec3 volPos = volumeBuffer.volumeData[baseIndex].xyz;
            volumeT = length(volPos - currentRay.origin);
        }
        
        // Check for sphere intersection
        bool hitSphere = traceRay(currentRay, rec, tMin, MAX_DISTANCE);
        
        // Determine which is closer
        if (hitSphere && rec.t < volumeT) {
            // Sphere is closer
            vec3 viewDir = normalize(currentRay.origin - rec.point);
            vec3 surfaceColor = calculateLighting(rec, viewDir);
            
            // Get material transparency
            float transparency = 0.0;
            float reflectivity = 0.0;
            if (rec.materialIndex >= 0 && rec.materialIndex < pushConst.numSpheres + 16) {
                Material mat = materialBuffer.materialData[rec.materialIndex];
                transparency = mat.transIsoEmissive.x;
                reflectivity = mat.diffuseSpecularShiny.w;
            }
            
            float opacity = 1.0 - transparency;
            float remainingOpacity = 1.0 - accumulatedOpacity;
            
            // Mix blend current color with surface
            finalColor = mix(finalColor, surfaceColor, opacity * remainingOpacity);
            accumulatedOpacity += opacity * remainingOpacity;
            
            // Continue ray through/reflected
            if (transparency > 0.01 && accumulatedOpacity < OPACITY_THRESHOLD) {
                // Continue through transparent surface
                currentRay.origin = rec.point + currentRay.direction * EPSILON;
                tMin = EPSILON;
            } else if (reflectivity > 0.01) {
                // Reflect
                vec3 reflectDir = reflect(currentRay.direction, rec.normal);
                currentRay.origin = rec.point + rec.normal * EPSILON;
                currentRay.direction = reflectDir;
                tMin = EPSILON;
            } else {
                break;
            }
        } else if (volumeAlpha > 0.0) {
            // Volume is closer or sphere missed
            float remainingOpacity = 1.0 - accumulatedOpacity;
            
            // Mix blend with volumetric
            finalColor = mix(finalColor, volumetricContribution, volumeAlpha * remainingOpacity);
            accumulatedOpacity += volumeAlpha * remainingOpacity;
            
            // Continue ray through volume (simplified - just skip past it)
            currentRay.origin = currentRay.origin + currentRay.direction * (volumeT + 2.0);
            tMin = EPSILON;
        } else {
            // Nothing hit, render background
            vec3 unitDir = normalize(currentRay.direction);
            float t = 0.5 * (unitDir.y + 1.0);
            vec3 bgColor = (1.0 - t) * pushConst.bgColorBottom + t * pushConst.bgColorTop;
            
            float remainingOpacity = 1.0 - accumulatedOpacity;
            finalColor = mix(finalColor, bgColor, remainingOpacity);
            break;
        }
    }
    
    return finalColor;
}

layout(local_size_x = 16, local_size_y = 16) in;
void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    
    if (pixelCoord.x >= imageSize(outputImage).x || pixelCoord.y >= imageSize(outputImage).y) {
        return;
    }
    
    vec2 uv = vec2(pixelCoord) / imageSize(outputImage);
    uv.y = 1.0 - uv.y;
    
    Ray ray = createCameraRay(uv);
    vec3 color = traceIterative(ray);
    
    color = clamp(color, 0.0, 1.0);
    imageStore(outputImage, pixelCoord, vec4(color.b, color.g, color.r, 1.0));
}
