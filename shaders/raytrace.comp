#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_arithmetic : enable

// Optimize for AMD RDNA 3 wave32/wave64 architecture
layout(local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0, rgba8) uniform image2D outputImage;

struct Sphere {
    vec3 center;
    float radius;
    int materialIndex;
    int padding[3];
};

layout(set = 0, binding = 1) readonly buffer SphereBuf {
    Sphere sphereData[];
} sphereBuffer;

struct Ellipsoid {
    vec3 center;
    float padding1;
    vec3 radii;
    int materialIndex;
    vec3 color;
    float padding2;
};

layout(set = 0, binding = 2) readonly buffer EllipsoidBuf {
    Ellipsoid ellipsoidData[];
} ellipsoidBuffer;

struct Material {
    vec4 colorAndAmbient;      // color.xyz, ambient.w
    vec4 diffuseSpecularShiny; // diffuse.x, specular.y, shininess.z, reflectivity.w
    vec4 transparencyEmissive; // transparency.x, emissiveStrength.y, shaderFunctionIndex.z, padding.w
    vec4 emissive;             // emissive.xyz, padding.w
    vec4 scatterAndAbsorption; // scatterColor.xyz, absorptionCoeff.w
};

layout(set = 0, binding = 3, std430) readonly buffer MaterialBuf {
    Material materialData[];
} materialBuffer;

layout(set = 0, binding = 4) readonly buffer LightBuf {
    vec4 lightData[];
} lightBuffer;

layout(set = 0, binding = 5) readonly buffer VolumeBuf {
    vec4 volumeData[];
} volumeBuffer;

layout(set = 0, binding = 6) readonly buffer VoxelDataBuf {
    uint voxelData[];
} voxelDataBuffer;

layout(push_constant) uniform PushConstants {
    mat4 cameraMatrix;
    vec3 cameraPos;
    float time;
    int numSpheres;
    int numEllipsoids;
    int numLights;
    int numVolumes;
    int maxDepth;
    int padding1;
    int padding2;
    int padding3;
    vec3 bgColorTop;
    float padding4;
    vec3 bgColorBottom;
    float padding5;
} pushConst;

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct HitRecord {
    vec3 point;
    vec3 normal;
    float t;
    int materialIndex;
    bool hit;
};

const float PI = 3.14159265359;
const float MAX_DISTANCE = 1e10;
const float EPSILON = 0.001;

float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

Ray createCameraRay(vec2 uv) {
    Ray ray;
    ray.origin = pushConst.cameraPos;
    
    vec3 target = vec3(2.0, 1.5, 0.0);
    vec3 forward = normalize(target - ray.origin);
    vec3 right = normalize(cross(forward, vec3(0, 1, 0)));
    vec3 up = normalize(cross(right, forward));
    
    float fov = tan(radians(60.0) / 2.0);
    float aspectRatio = imageSize(outputImage).x / float(imageSize(outputImage).y);
    
    ray.direction = normalize(
        forward + 
        (uv.x - 0.5) * aspectRatio * fov * right + 
        (uv.y - 0.5) * fov * up
    );
    
    return ray;
}

bool hitSphere(Ray ray, vec3 center, float radius, float tMin, float tMax, inout HitRecord rec) {
    vec3 oc = ray.origin - center;
    
    // Fast ray-sphere intersection using half_b optimization
    float half_b = dot(oc, ray.direction);
    float c = dot(oc, oc) - radius * radius;
    
    // Early exit using subgroup ballot for branch coherency
    float discriminant = half_b * half_b - c;
    if (discriminant < 0.0) return false;
    
    float sqrtDisc = sqrt(discriminant);
    float t = -half_b - sqrtDisc;
    
    if (t < tMin || t > tMax) {
        t = -half_b + sqrtDisc;
        if (t < tMin || t > tMax) return false;
    }
    
    rec.t = t;
    rec.point = ray.origin + t * ray.direction;
    // multiply by reciprocal instead of normalize
    rec.normal = (rec.point - center) * (1.0 / radius);
    rec.hit = true;
    
    return true;
}

// Ellipsoid intersection - transforms ray to unit sphere space
bool hitEllipsoid(Ray ray, vec3 center, vec3 radii, float tMin, float tMax, inout HitRecord rec) {
    vec3 oc = ray.origin - center;
    
    // Scale by inverse radii
    vec3 invRadii = 1.0 / radii;
    vec3 ocScaled = oc * invRadii;
    vec3 dirScaled = ray.direction * invRadii;
    
    // solve for unit sphere intersection
    float a = dot(dirScaled, dirScaled);
    float half_b = dot(ocScaled, dirScaled);
    float c = dot(ocScaled, ocScaled) - 1.0;
    
    float discriminant = half_b * half_b - a * c;
    if (discriminant < 0.0) return false;
    
    float sqrtDisc = sqrt(discriminant);
    float t = (-half_b - sqrtDisc) / a;
    
    if (t < tMin || t > tMax) {
        t = (-half_b + sqrtDisc) / a;
        if (t < tMin || t > tMax) return false;
    }
    
    rec.t = t;
    rec.point = ray.origin + t * ray.direction;
    // Normal in ellipsoid space: gradient of (x/rx)^2 + (y/ry)^2 + (z/rz)^2 = 1
    vec3 normalUnscaled = (rec.point - center) * invRadii * invRadii;
    rec.normal = normalize(normalUnscaled);
    rec.hit = true;
    
    return true;
}

bool traceRay(Ray ray, out HitRecord rec, float tMin, float tMax) {
    float closestT = tMax;
    bool hitAnything = false;
    
    for (int i = 0; i < pushConst.numSpheres; i++) {
        Sphere sphere = sphereBuffer.sphereData[i];
        
        HitRecord tempRec;
        if (hitSphere(ray, sphere.center, sphere.radius, tMin, closestT, tempRec)) {
            closestT = tempRec.t;
            rec = tempRec;
            rec.materialIndex = sphere.materialIndex;
            hitAnything = true;
        }
    }
    
    for (int i = 0; i < pushConst.numEllipsoids; i++) {
        Ellipsoid ellipsoid = ellipsoidBuffer.ellipsoidData[i];
        
        HitRecord tempRec;
        if (hitEllipsoid(ray, ellipsoid.center, ellipsoid.radii, tMin, closestT, tempRec)) {
            closestT = tempRec.t;
            rec = tempRec;
            rec.materialIndex = ellipsoid.materialIndex;
            hitAnything = true;
        }
    }
    
    return hitAnything;
}

float getShadowFactor(vec3 point, vec3 lightPos) {
    Ray shadowRay;
    shadowRay.origin = point;
    vec3 lightVec = lightPos - point;
    float distToLight = length(lightVec);
    shadowRay.direction = lightVec / distToLight; // Normalized, reusing calculated length
    
    HitRecord rec;
    // Early return with binary result (0 or 1)
    return traceRay(shadowRay, rec, EPSILON, distToLight) ? 0.0 : 1.0;
}

// Surface shader data structure - contains all data needed for custom shading
struct SurfaceShaderData {
    vec3 hitPoint;          // World space hit position
    vec3 normal;            // Surface normal
    vec3 viewDir;           // Direction to camera (normalized)
    vec3 surfaceColor;      // Base material color
    float ambient;          // Ambient coefficient
    float diffuse;          // Diffuse coefficient
    float specular;         // Specular coefficient
    float shininess;        // Shininess exponent
    float emissiveStrength; // Emissive strength
    float time;             // Current time for animations
    int materialIndex;      // Material index for additional data access
};

// Surface shader return structure
struct SurfaceShaderResult {
    vec3 color;             // Final surface color
    vec3 emissive;          // Emissive contribution (added to color)
    float emissiveStrength; // Emissive strength (for lighting other objects)
    float ambient;          // Modified ambient coefficient
    float diffuse;          // Modified diffuse coefficient
    float specular;         // Modified specular coefficient
    float shininess;        // Modified shininess
};

// Custom surface shader functions loaded from separate files
// Shader 0: Phong (handled in calculateLighting)
// SURFACE_SHADERS_PLACEHOLDER
// This will be replaced at runtime with shader includes

vec3 calculateLighting(HitRecord rec, vec3 viewDir) {
    // Load material once
    Material mat = materialBuffer.materialData[rec.materialIndex];
    vec3 surfaceColor = mat.colorAndAmbient.xyz;
    float ambient = mat.colorAndAmbient.w;
    float diffuseCoeff = mat.diffuseSpecularShiny.x;
    float specularCoeff = mat.diffuseSpecularShiny.y;
    float shininess = mat.diffuseSpecularShiny.z;
    float emissiveStrength = mat.transparencyEmissive.y;
    int shaderFunctionIndex = int(mat.transparencyEmissive.z);
    
    // Check if using custom surface shader
    if (shaderFunctionIndex != 0) {
        SurfaceShaderData shaderData;
        shaderData.hitPoint = rec.point;
        shaderData.normal = rec.normal;
        shaderData.viewDir = viewDir;
        shaderData.surfaceColor = surfaceColor;
        shaderData.ambient = ambient;
        shaderData.diffuse = diffuseCoeff;
        shaderData.specular = specularCoeff;
        shaderData.shininess = shininess;
        shaderData.emissiveStrength = emissiveStrength;
        shaderData.time = pushConst.time;
        shaderData.materialIndex = rec.materialIndex;
        
        // Dispatch to custom shader function (generated at compile time)
        SurfaceShaderResult shaderResult;
        shaderResult.color = vec3(0.0);
        shaderResult.emissive = vec3(0.0);
        shaderResult.emissiveStrength = emissiveStrength;
        shaderResult.ambient = ambient;
        shaderResult.diffuse = diffuseCoeff;
        shaderResult.specular = specularCoeff;
        shaderResult.shininess = shininess;
        // SURFACE_SHADER_DISPATCH_PLACEHOLDER
        
        // Return combined color and emissive
        return shaderResult.color + shaderResult.emissive;
        
    }
    
    // Default: Phong shading (shader function 0)
    
    // Start with ambient
    vec3 finalColor = ambient * surfaceColor;
    
    // Add emissive contribution
    if (emissiveStrength > 0.0) {
        finalColor += surfaceColor * emissiveStrength;
    }
    
    // Sample light from explicit light sources
    for (int i = 0; i < pushConst.numLights; i++) {
        vec4 lightData = lightBuffer.lightData[i];
        vec3 lightPos = lightData.xyz;
        float intensity = lightData.w;
        
        // Early shadow test before expensive calculations
        float shadowFactor = getShadowFactor(rec.point, lightPos);
        if (shadowFactor < 0.5) continue;
        
        vec3 lightVec = lightPos - rec.point;
        float distance = length(lightVec);
        vec3 lightDir = lightVec / distance; // Reuse calculated length
        
        float attenuation = intensity / (1.0 + 0.09 * distance + 0.032 * distance * distance);
        
        // Diffuse
        float diffuseStrength = max(0.0, dot(rec.normal, lightDir));
        vec3 diffuse = diffuseCoeff * diffuseStrength * surfaceColor * attenuation;
        
        // Specular (Blinn-Phong)
        vec3 halfDir = normalize(lightDir + viewDir);
        float specularStrength = pow(max(0.0, dot(rec.normal, halfDir)), shininess);
        vec3 specular = surfaceColor * specularCoeff * specularStrength * attenuation;
        
        finalColor += (diffuse + specular);
    }
    
    // Sample light from emissive spheres
    for (int i = 0; i < pushConst.numSpheres; i++) {
        Sphere sphere = sphereBuffer.sphereData[i];
        Material sphereMat = materialBuffer.materialData[sphere.materialIndex];
        float sphereEmissive = sphereMat.transparencyEmissive.y;
        int sphereShaderIndex = int(sphereMat.transparencyEmissive.z);
        
        if (sphereEmissive > 0.0) {
            vec3 emissiveColor = sphereMat.colorAndAmbient.xyz;
            
            // If the sphere uses a custom shader, evaluate it to get the emissive contribution
            if (sphereShaderIndex != 0) {
                // Create shader data for the sphere (approximating hit point at sphere center direction)
                vec3 toSphere = sphere.center - rec.point;
                float distToSphere = length(toSphere);
                vec3 dirToSphere = toSphere / distToSphere;
                vec3 approximateHitPoint = sphere.center - dirToSphere * sphere.radius;
                vec3 approximateNormal = -dirToSphere;
                
                SurfaceShaderData sphereShaderData;
                sphereShaderData.hitPoint = approximateHitPoint;
                sphereShaderData.normal = approximateNormal;
                sphereShaderData.viewDir = dirToSphere;
                sphereShaderData.surfaceColor = sphereMat.colorAndAmbient.xyz;
                sphereShaderData.ambient = sphereMat.colorAndAmbient.w;
                sphereShaderData.diffuse = sphereMat.diffuseSpecularShiny.x;
                sphereShaderData.specular = sphereMat.diffuseSpecularShiny.y;
                sphereShaderData.shininess = sphereMat.diffuseSpecularShiny.z;
                sphereShaderData.emissiveStrength = sphereEmissive;
                sphereShaderData.time = pushConst.time;
                sphereShaderData.materialIndex = sphere.materialIndex;
                
                SurfaceShaderResult sphereShaderResult;
                sphereShaderResult.color = vec3(0.0);
                sphereShaderResult.emissive = vec3(0.0);
                sphereShaderResult.emissiveStrength = sphereEmissive;
                sphereShaderResult.ambient = sphereMat.colorAndAmbient.w;
                sphereShaderResult.diffuse = sphereMat.diffuseSpecularShiny.x;
                sphereShaderResult.specular = sphereMat.diffuseSpecularShiny.y;
                sphereShaderResult.shininess = sphereMat.diffuseSpecularShiny.z;
                // SURFACE_SHADER_DISPATCH_FOR_SPHERE_EMISSIVE
                
                // Use the shader's emissive output and strength
                emissiveColor = sphereShaderResult.emissive;
                sphereEmissive = sphereShaderResult.emissiveStrength;
                
                // If shader returns zero emissive, skip this sphere
                if (length(emissiveColor) < 0.001) continue;
            }
            
            vec3 toSphere = sphere.center - rec.point;
            float distToSphere = length(toSphere);
            vec3 dirToSphere = toSphere / distToSphere;
            
            // Check if sphere is above the surface
            float alignment = dot(rec.normal, dirToSphere);
            if (alignment > 0.0) {
                // Check if path is blocked by OTHER objects (not the emissive sphere itself)
                Ray shadowRay;
                shadowRay.origin = rec.point + rec.normal * EPSILON;
                shadowRay.direction = dirToSphere;
                
                HitRecord shadowHit;
                // Check for occlusion BEFORE reaching the emissive sphere surface
                float checkDist = distToSphere - sphere.radius - EPSILON;
                bool blocked = traceRay(shadowRay, shadowHit, EPSILON, checkDist);
                
                if (!blocked) {
                    // Calculate lighting contribution from emissive sphere
                    float attenuation = sphereEmissive / (1.0 + 0.5 * distToSphere + 0.1 * distToSphere * distToSphere);
                    float diffuseStrength = alignment;
                    // Apply emissive light to surface
                    vec3 emissiveLight = diffuseStrength * emissiveColor * attenuation;
                    finalColor += emissiveLight;
                }
            }
        }
    }
    
    // Sample light from emissive ellipsoids
    for (int i = 0; i < pushConst.numEllipsoids; i++) {
        Ellipsoid ellipsoid = ellipsoidBuffer.ellipsoidData[i];
        Material ellipsoidMat = materialBuffer.materialData[ellipsoid.materialIndex];
        float ellipsoidEmissive = ellipsoidMat.transparencyEmissive.y;
        
        if (ellipsoidEmissive > 0.0) {
            vec3 emissiveColor = ellipsoidMat.colorAndAmbient.xyz;
            vec3 toEllipsoid = ellipsoid.center - rec.point;
            float distToEllipsoid = length(toEllipsoid);
            vec3 dirToEllipsoid = toEllipsoid / distToEllipsoid;
            
            // Check if ellipsoid is above the surface
            float alignment = dot(rec.normal, dirToEllipsoid);
            if (alignment > 0.0) {
                // Check if path is blocked by OTHER objects
                Ray shadowRay;
                shadowRay.origin = rec.point + rec.normal * EPSILON;
                shadowRay.direction = dirToEllipsoid;
                
                HitRecord shadowHit;
                // Approximate ellipsoid radius as max of its radii
                float approxRadius = max(max(ellipsoid.radii.x, ellipsoid.radii.y), ellipsoid.radii.z);
                float checkDist = distToEllipsoid - approxRadius - EPSILON;
                bool blocked = traceRay(shadowRay, shadowHit, EPSILON, checkDist);
                
                if (!blocked) {
                    // Calculate lighting contribution from emissive ellipsoid
                    float attenuation = ellipsoidEmissive / (1.0 + 0.5 * distToEllipsoid + 0.1 * distToEllipsoid * distToEllipsoid);
                    float diffuseStrength = alignment;
                    vec3 emissiveLight = diffuseStrength * emissiveColor * attenuation;
                    finalColor += emissiveLight;
                }
            }
        }
    }
    
    return finalColor;
}

float sampleVolume(vec3 worldPos, int volumeIndex) {
    if (volumeIndex >= pushConst.numVolumes) return 0.0;
    
    // Read volume data from buffer (4 vec4s per volume)
    int baseIndex = volumeIndex * 4;
    vec3 volPos = volumeBuffer.volumeData[baseIndex].xyz;
    vec3 v0 = volumeBuffer.volumeData[baseIndex + 1].xyz;
    int res_x = floatBitsToInt(volumeBuffer.volumeData[baseIndex + 1].w);
    vec3 v1 = volumeBuffer.volumeData[baseIndex + 2].xyz;
    int res_y = floatBitsToInt(volumeBuffer.volumeData[baseIndex + 2].w);
    int res_z = floatBitsToInt(volumeBuffer.volumeData[baseIndex + 3].x);
    
    vec3 relPos = worldPos - volPos;
    
    if (any(lessThan(relPos, v0)) || any(greaterThan(relPos, v1))) {
        return 0.0;
    }
    
    relPos = (relPos - v0) / (v1 - v0);
    
    ivec3 voxelIdx = ivec3(relPos * vec3(float(res_x), float(res_y), float(res_z)));
    voxelIdx = clamp(voxelIdx, ivec3(0), ivec3(res_x - 1, res_y - 1, res_z - 1));
    
    int index = voxelIdx.x + voxelIdx.y * res_x + voxelIdx.z * res_x * res_y;
    
    // Extract byte from packed uint array
    int uintIndex = index / 4;
    int byteInUint = index % 4;
    uint packedData = voxelDataBuffer.voxelData[uintIndex];
    uint byteValue = (packedData >> (byteInUint * 8)) & 0xFF;
    
    return float(byteValue) / 255.0;
}

bool intersectBox(Ray ray, vec3 boxMin, vec3 boxMax, out float tNear, out float tFar) {
    // Optimized ray-box intersection using fast division
    vec3 invDir = 1.0 / (ray.direction + vec3(1e-8)); // Avoid division by zero
    vec3 t0 = (boxMin - ray.origin) * invDir;
    vec3 t1 = (boxMax - ray.origin) * invDir;
    
    vec3 tmin = min(t0, t1);
    vec3 tmax = max(t0, t1);
    
    tNear = max(max(tmin.x, tmin.y), tmin.z);
    tFar = min(min(tmax.x, tmax.y), tmax.z);
    
    return tFar >= tNear && tFar > 0.0;
}

vec3 rayMarchVolume(Ray ray, float maxDist, int volumeIndex) {
    if (pushConst.numVolumes <= 0) return vec3(-1.0);
    
    // Cache volume data from buffer (4 vec4s per volume)
    int baseIndex = volumeIndex * 4;
    vec4 volData0 = volumeBuffer.volumeData[baseIndex];
    vec4 volData1 = volumeBuffer.volumeData[baseIndex + 1];
    vec4 volData2 = volumeBuffer.volumeData[baseIndex + 2];
    vec4 volData3 = volumeBuffer.volumeData[baseIndex + 3];
    
    vec3 volPos = volData0.xyz;
    vec3 v0 = volData1.xyz;
    vec3 v1 = volData2.xyz;
    int materialIndex = floatBitsToInt(volData3.y);
    
    vec3 boxMin = volPos + v0;
    vec3 boxMax = volPos + v1;
    
    float tNear, tFar;
    if (!intersectBox(ray, boxMin, boxMax, tNear, tFar)) {
        return vec3(-1.0);
    }
    
    tNear = max(tNear, 0.0);
    tFar = min(tFar, maxDist);
    Material mat = materialBuffer.materialData[materialIndex];
    vec3 materialColor = mat.scatterAndAbsorption.xyz;
    float absorptionCoeff = mat.scatterAndAbsorption.w;
    
    float stepSize = 0.02; // Doubled from 0.01
    float t = tNear;
    float accumulatedDensity = 0.0;
    int stepCount = 0;
    const int maxSteps = 500; // Reduced from 1000
    const float TRANSPARENCY_EPSILON = 0.0001;
    
    // Early termination if we find enough solid voxels
    while (t < tFar && stepCount < maxSteps) {
        vec3 samplePos = ray.origin + ray.direction * t;
        float density = sampleVolume(samplePos, volumeIndex);
        
        float sampleAlpha = density * absorptionCoeff;
        accumulatedDensity += (1.0 - accumulatedDensity) * sampleAlpha;

        t += stepSize;
        stepCount++;
        
    }
    
    // Branchless result calculation
    return mix(vec3(-1.0), materialColor * accumulatedDensity, float(accumulatedDensity >= TRANSPARENCY_EPSILON));
}

vec3 renderVolumetric(Ray ray) {
    if (pushConst.numVolumes <= 0) {
        return vec3(0.0);
    }
    
    return rayMarchVolume(ray, 100.0, 0);
}

vec3 traceIterative(Ray initialRay) {
    vec3 finalColor = vec3(0.0);
    vec3 throughput = vec3(1.0); // How much light can pass through bounces
    const float THROUGHPUT_THRESHOLD = 0.001; // When to stop tracing
    
    Ray currentRay = initialRay;
    float tMin = EPSILON;
    
    const int maxBounces = 10;
    
    for (int bounce = 0; bounce < maxBounces; bounce++) {
        if (length(throughput) < THROUGHPUT_THRESHOLD) break;
        
        HitRecord rec;
        
        bool hitSolid = traceRay(currentRay, rec, tMin, MAX_DISTANCE);

        vec3 volumetricContribution = vec3(-1.0);
        float volumeAlpha = 0.0;
        
        if (pushConst.numVolumes > 0) {
            volumetricContribution = rayMarchVolume(currentRay, hitSolid ? rec.t : MAX_DISTANCE, 0);
            
            if (volumetricContribution.x >= 0.0) {
                volumeAlpha = clamp(length(volumetricContribution) / length(vec3(1.0)), 0.0, 1.0);
            }
        }
        
        // Process volumetric contribution first
        if (volumeAlpha > 0.0) {
            finalColor += throughput * volumetricContribution * volumeAlpha;
            throughput *= (1.0 - volumeAlpha);
        }
        
        // Now handle solid object hit
        if (hitSolid) {
            // Load material to check for emission
            Material mat = materialBuffer.materialData[rec.materialIndex];
            float emissiveStrength = mat.transparencyEmissive.y;
            vec3 surfaceColor = mat.colorAndAmbient.xyz;
            
            // Add emissive contribution (direct emission from this surface)
            if (emissiveStrength > 0.0) {
                finalColor += throughput * surfaceColor * emissiveStrength;
            }
            
            // Calculate lighting (diffuse + specular from lights)
            vec3 viewDir = normalize(currentRay.origin - rec.point);
            vec3 litColor = calculateLighting(rec, viewDir);
            
            float transparency = mat.transparencyEmissive.x;
            float reflectivity = mat.diffuseSpecularShiny.w;
            
            // Handle reflections
            if (reflectivity > 0.01) {
                float surfaceOpacity = (1.0 - reflectivity) * (1.0 - transparency);
                finalColor += throughput * litColor * surfaceOpacity;
                throughput *= reflectivity;
                
                // Reflect ray to trace reflection
                vec3 reflectDir = reflect(currentRay.direction, rec.normal);
                currentRay.origin = rec.point + rec.normal * EPSILON;
                currentRay.direction = reflectDir;
                tMin = EPSILON;
            } else if (transparency > 0.01) {
                // Transparent surface - continue through
                float opacity = 1.0 - transparency;
                finalColor += throughput * litColor * opacity;
                throughput *= transparency;
                
                currentRay.origin = rec.point + currentRay.direction * EPSILON;
                tMin = EPSILON;
            } else {
                // Opaque, non-reflective surface - add final contribution and stop
                finalColor += throughput * litColor;
                break;
            }
        } else {
            // No solid hit - render background
            vec3 unitDir = normalize(currentRay.direction);
            float t = 0.5 * (unitDir.y + 1.0);
            vec3 bgColor = mix(pushConst.bgColorBottom, pushConst.bgColorTop, t);
            
            finalColor += throughput * bgColor;
            break;
        }
    }
    
    return finalColor;
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageDims = imageSize(outputImage);
    
    // Early exit for out-of-bounds invocations
    if (pixelCoord.x >= imageDims.x || pixelCoord.y >= imageDims.y) {
        return;
    }
    
    vec2 uv = vec2(pixelCoord) / vec2(imageDims);
    uv.y = 1.0 - uv.y;
    
    // Trace ray through scene
    Ray ray = createCameraRay(uv);
    vec3 color = traceIterative(ray);
    
    // Clamp and store result
    color = clamp(color, 0.0, 1.0);
    imageStore(outputImage, pixelCoord, vec4(color, 1.0));
}
