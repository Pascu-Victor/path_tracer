#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

layout(set = 0, binding = 0, rgba8) uniform image2D outputImage;

struct Sphere {
    vec3 center;
    float radius;
    int materialIndex;
    int padding[3];
};

layout(set = 0, binding = 1) readonly buffer SphereBuf {
    Sphere sphereData[];
} sphereBuffer;

struct Material {
    vec4 colorAndAmbient;      // color.xyz, ambient.w
    vec4 diffuseSpecularShiny; // diffuse.x, specular.y, shininess.z, reflectivity.w
    vec4 transIsoEmissive;     // transparency.x, isVolumetric.y, emissiveStrength.z, padding.w
    vec4 emissive;             // emissive.xyz, padding.w
    vec4 scatterAndAbsorption; // scatterColor.xyz, absorptionCoeff.w
};

layout(set = 0, binding = 2, std430) readonly buffer MaterialBuf {
    Material materialData[];
} materialBuffer;

layout(set = 0, binding = 3) readonly buffer LightBuf {
    vec4 lightData[];
} lightBuffer;

layout(set = 0, binding = 4) readonly buffer VolumeBuf {
    vec4 volumeData[];
} volumeBuffer;

layout(set = 0, binding = 5) readonly buffer VoxelDataBuf {
    uint voxelData[];
} voxelDataBuffer;

layout(push_constant) uniform PushConstants {
    mat4 cameraMatrix;
    vec3 cameraPos;
    float time;
    int numSpheres;
    int numLights;
    int numVolumes;
    int maxDepth;
    vec3 bgColorTop;
    float padding1;
    vec3 bgColorBottom;
    float padding2;
} pushConst;

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct HitRecord {
    vec3 point;
    vec3 normal;
    float t;
    int materialIndex;
    bool hit;
};

const float PI = 3.14159265359;
const float MAX_DISTANCE = 1e10;
const float EPSILON = 0.001;

float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

Ray createCameraRay(vec2 uv) {
    Ray ray;
    ray.origin = pushConst.cameraPos;
    
    vec3 target = vec3(2.0, 1.5, 0.0);
    vec3 forward = normalize(target - ray.origin);
    vec3 right = normalize(cross(forward, vec3(0, 1, 0)));
    vec3 up = normalize(cross(right, forward));
    
    float fov = tan(radians(60.0) / 2.0);
    float aspectRatio = imageSize(outputImage).x / float(imageSize(outputImage).y);
    
    ray.direction = normalize(
        forward + 
        (uv.x - 0.5) * aspectRatio * fov * right + 
        (uv.y - 0.5) * fov * up
    );
    
    return ray;
}

// Sphere intersection - optimized to reduce redundant calculations
bool hitSphere(Ray ray, vec3 center, float radius, float tMin, float tMax, inout HitRecord rec) {
    vec3 oc = ray.origin - center;
    // Assume ray.direction is normalized, so dot(ray.direction, ray.direction) = 1.0
    float half_b = dot(oc, ray.direction);
    float c = dot(oc, oc) - radius * radius;
    
    // Optimized discriminant calculation (using half_b instead of b)
    float discriminant = half_b * half_b - c;
    if (discriminant < 0.0) return false;
    
    float sqrtDisc = sqrt(discriminant);
    float t = -half_b - sqrtDisc;
    
    if (t < tMin || t > tMax) {
        t = -half_b + sqrtDisc;
        if (t < tMin || t > tMax) return false;
    }
    
    rec.t = t;
    rec.point = ray.origin + t * ray.direction;
    rec.normal = (rec.point - center) * (1.0 / radius); // Faster than normalize
    rec.hit = true;
    
    return true;
}

bool traceRay(Ray ray, out HitRecord rec, float tMin, float tMax) {
    float closestT = tMax;
    bool hitAnything = false;
    
    // Cache sphere data to reduce buffer reads
    for (int i = 0; i < pushConst.numSpheres; i++) {
        Sphere sphere = sphereBuffer.sphereData[i];
        
        HitRecord tempRec;
        if (hitSphere(ray, sphere.center, sphere.radius, tMin, closestT, tempRec)) {
            closestT = tempRec.t;
            rec = tempRec;
            rec.materialIndex = sphere.materialIndex;
            hitAnything = true;
        }
    }
    
    return hitAnything;
}

float getShadowFactor(vec3 point, vec3 lightPos) {
    Ray shadowRay;
    shadowRay.origin = point;
    vec3 lightVec = lightPos - point;
    float distToLight = length(lightVec);
    shadowRay.direction = lightVec / distToLight; // Normalized, reusing calculated length
    
    HitRecord rec;
    // Early return with binary result (0 or 1)
    return traceRay(shadowRay, rec, EPSILON, distToLight) ? 0.0 : 1.0;
}

vec3 calculateLighting(HitRecord rec, vec3 viewDir) {
    // Load material once
    Material mat = materialBuffer.materialData[rec.materialIndex];
    vec3 surfaceColor = mat.colorAndAmbient.xyz;
    
    // Start with ambient
    vec3 finalColor = vec3(0.1) * surfaceColor;
    
    // Unroll small light loops for better performance
    for (int i = 0; i < pushConst.numLights; i++) {
        vec4 lightData = lightBuffer.lightData[i];
        vec3 lightPos = lightData.xyz;
        float intensity = lightData.w;
        
        // Early shadow test before expensive calculations
        float shadowFactor = getShadowFactor(rec.point, lightPos);
        if (shadowFactor < 0.5) continue;
        
        vec3 lightVec = lightPos - rec.point;
        float distance = length(lightVec);
        vec3 lightDir = lightVec / distance; // Reuse calculated length
        
        float attenuation = intensity / (1.0 + 0.09 * distance + 0.032 * distance * distance);
        
        // Diffuse
        float diffuseStrength = max(0.0, dot(rec.normal, lightDir));
        vec3 diffuse = vec3(0.7) * diffuseStrength * surfaceColor * attenuation;
        
        // Specular (Blinn-Phong)
        vec3 halfDir = normalize(lightDir + viewDir);
        float specularStrength = pow(max(0.0, dot(rec.normal, halfDir)), 32.0);
        vec3 specular = vec3(0.3) * specularStrength * attenuation;
        
        finalColor += (diffuse + specular);
    }
    
    return finalColor;
}

float sampleVolume(vec3 worldPos, int volumeIndex) {
    if (volumeIndex >= pushConst.numVolumes) return 0.0;
    
    // Read volume data from buffer (4 vec4s per volume)
    int baseIndex = volumeIndex * 4;
    vec3 volPos = volumeBuffer.volumeData[baseIndex].xyz;
    vec3 v0 = volumeBuffer.volumeData[baseIndex + 1].xyz;
    int res_x = floatBitsToInt(volumeBuffer.volumeData[baseIndex + 1].w);
    vec3 v1 = volumeBuffer.volumeData[baseIndex + 2].xyz;
    int res_y = floatBitsToInt(volumeBuffer.volumeData[baseIndex + 2].w);
    int res_z = floatBitsToInt(volumeBuffer.volumeData[baseIndex + 3].x);
    
    vec3 relPos = worldPos - volPos;
    
    if (any(lessThan(relPos, v0)) || any(greaterThan(relPos, v1))) {
        return 0.0;
    }
    
    relPos = (relPos - v0) / (v1 - v0);
    
    ivec3 voxelIdx = ivec3(relPos * vec3(float(res_x), float(res_y), float(res_z)));
    voxelIdx = clamp(voxelIdx, ivec3(0), ivec3(res_x - 1, res_y - 1, res_z - 1));
    
    int index = voxelIdx.x + voxelIdx.y * res_x + voxelIdx.z * res_x * res_y;
    
    // Extract byte from packed uint array
    int uintIndex = index / 4;
    int byteInUint = index % 4;
    uint packedData = voxelDataBuffer.voxelData[uintIndex];
    uint byteValue = (packedData >> (byteInUint * 8)) & 0xFF;
    
    return float(byteValue) / 255.0;
}

bool intersectBox(Ray ray, vec3 boxMin, vec3 boxMax, out float tNear, out float tFar) {
    // Optimized ray-box intersection using fast division
    vec3 invDir = 1.0 / (ray.direction + vec3(1e-8)); // Avoid division by zero
    vec3 t0 = (boxMin - ray.origin) * invDir;
    vec3 t1 = (boxMax - ray.origin) * invDir;
    
    vec3 tmin = min(t0, t1);
    vec3 tmax = max(t0, t1);
    
    tNear = max(max(tmin.x, tmin.y), tmin.z);
    tFar = min(min(tmax.x, tmax.y), tmax.z);
    
    return tFar >= tNear && tFar > 0.0;
}

vec3 rayMarchVolume(Ray ray, float maxDist, int volumeIndex) {
    if (pushConst.numVolumes <= 0) return vec3(-1.0);
    
    // Cache volume data from buffer (4 vec4s per volume)
    int baseIndex = volumeIndex * 4;
    vec4 volData0 = volumeBuffer.volumeData[baseIndex];
    vec4 volData1 = volumeBuffer.volumeData[baseIndex + 1];
    vec4 volData2 = volumeBuffer.volumeData[baseIndex + 2];
    vec4 volData3 = volumeBuffer.volumeData[baseIndex + 3];
    
    vec3 volPos = volData0.xyz;
    vec3 v0 = volData1.xyz;
    vec3 v1 = volData2.xyz;
    
    vec3 boxMin = volPos + v0;
    vec3 boxMax = volPos + v1;
    
    float tNear, tFar;
    if (!intersectBox(ray, boxMin, boxMax, tNear, tFar)) {
        return vec3(-1.0);
    }
    
    tNear = max(tNear, 0.0);
    tFar = min(tFar, maxDist);
    
    vec3 materialColor = vec3(0.7, 0.5, 0.3);
    
    // Adaptive ray marching with early termination
    // Increase step size for faster traversal, reduce max steps
    float stepSize = 0.02; // Doubled from 0.01
    float t = tNear;
    int nonZeroCount = 0;
    int stepCount = 0;
    const int maxSteps = 500; // Reduced from 1000
    
    // Early termination if we find enough solid voxels
    while (t < tFar && stepCount < maxSteps) {
        vec3 samplePos = ray.origin + ray.direction * t;
        float density = sampleVolume(samplePos, volumeIndex);
        
        nonZeroCount += int(density > 0.0); // Branchless increment
        
        t += stepSize;
        stepCount++;
        
        // Early exit if we've found a significant amount of solid voxels
        if (nonZeroCount > maxSteps / 4 && stepCount > 50) {
            break;
        }
    }
    
    // Branchless result calculation
    float ratio = float(nonZeroCount) / float(max(stepCount, 1));
    return mix(vec3(-1.0), materialColor * ratio, float(nonZeroCount > 0));
}

vec3 renderVolumetric(Ray ray) {
    if (pushConst.numVolumes <= 0) {
        return vec3(0.0);
    }
    
    return rayMarchVolume(ray, 100.0, 0);
}

vec3 traceIterative(Ray initialRay) {
    vec3 finalColor = vec3(0.0);
    float accumulatedOpacity = 0.0;
    const float OPACITY_THRESHOLD = 0.995; // Slightly lower for faster convergence
    
    Ray currentRay = initialRay;
    float tMin = EPSILON;
    
    // Reduce max bounces for better performance
    const int maxBounces = 6; // Reduced from 10
    
    for (int bounce = 0; bounce < maxBounces; bounce++) {
        if (accumulatedOpacity >= OPACITY_THRESHOLD) break;
        
        HitRecord rec;
        
        // Check for sphere intersection first (usually faster than volume)
        bool hitSphere = traceRay(currentRay, rec, tMin, MAX_DISTANCE);
        
        // Only check volumetric if we have volumes
        vec3 volumetricContribution = vec3(-1.0);
        float volumeT = MAX_DISTANCE;
        float volumeAlpha = 0.0;
        
        if (pushConst.numVolumes > 0) {
            volumetricContribution = rayMarchVolume(currentRay, hitSphere ? rec.t : MAX_DISTANCE, 0);
            
            if (volumetricContribution.x >= 0.0) {
                const vec3 maxColor = vec3(0.7, 0.5, 0.3);
                volumeAlpha = clamp(length(volumetricContribution) / length(maxColor), 0.0, 1.0);
                
                // Cache volume position read
                vec3 volPos = volumeBuffer.volumeData[0].xyz;
                volumeT = length(volPos - currentRay.origin);
            }
        }
        
        // Determine which is closer
        if (hitSphere && rec.t < volumeT) {
            // Sphere is closer
            vec3 viewDir = normalize(currentRay.origin - rec.point);
            vec3 surfaceColor = calculateLighting(rec, viewDir);
            
            // Load material once
            Material mat = materialBuffer.materialData[rec.materialIndex];
            float transparency = mat.transIsoEmissive.x;
            float reflectivity = mat.diffuseSpecularShiny.w;
            
            float opacity = 1.0 - transparency;
            float remainingOpacity = 1.0 - accumulatedOpacity;
            
            // Mix blend current color with surface
            finalColor = mix(finalColor, surfaceColor, opacity * remainingOpacity);
            accumulatedOpacity += opacity * remainingOpacity;
            
            // Continue ray through/reflected
            if (transparency > 0.01 && accumulatedOpacity < OPACITY_THRESHOLD) {
                // Continue through transparent surface
                currentRay.origin = rec.point + currentRay.direction * EPSILON;
                tMin = EPSILON;
            } else if (reflectivity > 0.01) {
                // Reflect
                vec3 reflectDir = reflect(currentRay.direction, rec.normal);
                currentRay.origin = rec.point + rec.normal * EPSILON;
                currentRay.direction = reflectDir;
                tMin = EPSILON;
            } else {
                break;
            }
        } else if (volumeAlpha > 0.0) {
            // Volume is closer or sphere missed
            float remainingOpacity = 1.0 - accumulatedOpacity;
            
            // Mix blend with volumetric
            finalColor = mix(finalColor, volumetricContribution, volumeAlpha * remainingOpacity);
            accumulatedOpacity += volumeAlpha * remainingOpacity;
            
            // Continue ray through volume
            currentRay.origin = currentRay.origin + currentRay.direction * (volumeT + 2.0);
            tMin = EPSILON;
        } else {
            // Nothing hit, render background
            vec3 unitDir = normalize(currentRay.direction);
            float t = 0.5 * (unitDir.y + 1.0);
            vec3 bgColor = mix(pushConst.bgColorBottom, pushConst.bgColorTop, t);
            
            float remainingOpacity = 1.0 - accumulatedOpacity;
            finalColor = mix(finalColor, bgColor, remainingOpacity);
            break;
        }
    }
    
    return finalColor;
}

layout(local_size_x = 16, local_size_y = 16) in;
void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    
    if (pixelCoord.x >= imageSize(outputImage).x || pixelCoord.y >= imageSize(outputImage).y) {
        return;
    }
    
    vec2 uv = vec2(pixelCoord) / imageSize(outputImage);
    uv.y = 1.0 - uv.y;
    
    Ray ray = createCameraRay(uv);
    vec3 color = traceIterative(ray);
    
    color = clamp(color, 0.0, 1.0);
    imageStore(outputImage, pixelCoord, vec4(color.r, color.g, color.b, 1.0));
}
